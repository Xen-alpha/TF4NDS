
void () TeamFortress_Discard = {

   newmis = spawn ();
   if ( (self.playerclass == 1.000) ) {

      newmis.ammo_rockets = self.ammo_rockets;

   } else {

      if ( (self.playerclass == 2.000) ) {

         newmis.ammo_rockets = self.ammo_rockets;
         newmis.ammo_cells = self.ammo_cells;

      } else {

         if ( (self.playerclass == 3.000) ) {

            newmis.ammo_cells = self.ammo_cells;
            newmis.ammo_nails = self.ammo_nails;

         } else {

            if ( (self.playerclass == 4.000) ) {

               newmis.ammo_cells = self.ammo_cells;
               newmis.ammo_nails = self.ammo_nails;

            } else {

               if ( (self.playerclass == 5.000) ) {

                  newmis.ammo_rockets = self.ammo_rockets;
                  newmis.ammo_cells = self.ammo_cells;

               } else {

                  if ( (self.playerclass == 6.000) ) {

                     newmis.ammo_rockets = self.ammo_rockets;
                     newmis.ammo_nails = self.ammo_nails;

                  } else {

                     if ( (self.playerclass == 7.000) ) {

                        newmis.ammo_nails = self.ammo_nails;

                     } else {

                        if ( (self.playerclass == 8.000) ) {

                           newmis.ammo_rockets = self.ammo_rockets;

                        } else {

                           if ( (self.playerclass == 9.000) ) {

                              newmis.ammo_rockets = self.ammo_rockets;

                           }

                        }

                     }

                  }

               }

            }

         }

      }

   }
   if ( !(((newmis.ammo_shells + newmis.ammo_nails) + newmis.ammo_rockets) + newmis.ammo_cells) ) {

      dremove (newmis);
      return ;

   }
   if ( newmis.ammo_shells ) {

      self.ammo_shells = 0.000;

   }
   if ( newmis.ammo_nails ) {

      self.ammo_nails = 0.000;

   }
   if ( newmis.ammo_rockets ) {

      self.ammo_rockets = 0.000;

   }
   if ( newmis.ammo_cells ) {

      self.ammo_cells = 0.000;

   }
   W_SetCurrentAmmo ();
   sound (self,3.000,"weapons/lock4.wav",1.000,1.000);
   if ( (self.team_no != 0.000) ) {

      increment_team_ammoboxes (self.team_no);
      if ( (num_team_ammoboxes (self.team_no) > (20.000 / number_of_teams)) ) {

         RemoveOldAmmobox (self.team_no);

      }

   } else {

      num_world_ammoboxes = (num_world_ammoboxes + 1.000);
      if ( (num_world_ammoboxes > 20.000) ) {

         RemoveOldAmmobox (0.000);

      }

   }
   newmis.enemy = self;
   newmis.health = time;
   newmis.weapon = 0.000;
   newmis.movetype = 6.000;
   newmis.solid = 1.000;
   newmis.classname = "ammobox";
   newmis.team_no = self.team_no;
   makevectors (self.v_angle);
   if ( self.v_angle_x ) {

      newmis.velocity = ((v_forward * 400.000) + (v_up * 200.000));

   } else {

      newmis.velocity = aim (self,10000.000);
      newmis.velocity = (newmis.velocity * 400.000);
      newmis.velocity_z = 200.000;

   }
   newmis.avelocity = '0.000 300.000 0.000';
   setsize (newmis,'0.000 0.000 0.000','0.000 0.000 0.000');
   setorigin (newmis,self.origin);
   newmis.nextthink = (time + 30.000);
   newmis.think = SUB_Remove;
   newmis.touch = TeamFortress_AmmoboxTouch;
   setmodel (newmis,"progs/backpack.mdl");

};

void () TeamFortress_SaveMe = {

   local entity te;
   local entity tl;

   if ( (self.last_saveme_sound < time) ) {

      if ( (random () < 0.800) ) {

         sound (self,1.000,"speech/saveme1.wav",1.000,1.000);

      } else {

         sound (self,1.000,"speech/saveme2.wav",1.000,1.000);

      }
      self.last_saveme_sound = (time + 4.000);

   }
   te = find (world,classname,"player");
   while ( te ) {

      if ( ((((self == te) || (te.playerclass == 5.000)) || (te.playerclass == 9.000)) || (te.playerclass == 8.000)) ) {

         if ( (((te.team_no == self.team_no) && (self.team_no != 0.000)) || (te.playerclass == 8.000)) ) {

            if ( visible (te) ) {

               msg_entity = te;
               tl = spawn ();
               tl.origin = self.origin;
               tl.origin_z = (tl.origin_z + 32.000);
               WriteByte (1.000,23.000);
               WriteByte (1.000,9.000);
               WriteEntity (1.000,tl);
               WriteCoord (1.000,tl.origin_x);
               WriteCoord (1.000,tl.origin_y);
               WriteCoord (1.000,(tl.origin_z + 24.000));
               WriteCoord (1.000,self.origin_x);
               WriteCoord (1.000,self.origin_y);
               WriteCoord (1.000,self.origin_z);
               dremove (tl);

            }

         }

      }
      te = find (te,classname,"player");

   }

};

void () TeamFortress_ID = {

   local vector src;
   local string st;
   local string cls;

   src = (self.origin + (v_forward * 10.000));
   src_z = (self.absmin_z + (self.size_z * 0.700));
   traceline (src,(src + (v_forward * 2048.000)),0.000,self);
   if ( ((trace_ent != world) && (trace_ent.origin != world.origin)) ) {

      if ( ((trace_ent.classname == "player") && (trace_ent.health > 0.000)) ) {

         self.StatusRefreshTime = (time + 1.500);
         if ( ((self.team_no != 0.000) && (self.team_no == trace_ent.team_no)) ) {

            cls = TeamFortress_GetClassName (trace_ent.playerclass);
            if ( (self.playerclass == 5.000) ) {

               st = NumberToString1000 (trace_ent.health);
               centerprint (self,"\n\n\n\n",trace_ent.netname,"\nFriendly ",cls,"\n",st," health\n");
               return ;

            } else {

               if ( (self.playerclass == 9.000) ) {

                  st = NumberToString1000 (trace_ent.armorvalue);
                  centerprint (self,"\n\n\n\n",trace_ent.netname,"\nFriendly ",cls,"\n",st," armor\n");
                  return ;

               }

            }
            centerprint (self,"\n\n\n\n",trace_ent.netname,"\nFriendly ",cls);
            return ;

         }
         if ( (trace_ent.playerclass == 8.000) ) {

            cls = TeamFortress_GetClassName (trace_ent.undercover_skin);
            if ( ((self.team_no != 0.000) && (self.team_no == trace_ent.undercover_team)) ) {

               if ( (self.playerclass == 5.000) ) {

                  st = NumberToString1000 (trace_ent.health);
                  if ( (trace_ent.undercover_skin != 0.000) ) {

                     centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nFriendly ",cls,"\n",st," health\n");

                  } else {

                     centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nFriendly Spy\n",st," health\n");

                  }
                  return ;

               } else {

                  if ( (self.playerclass == 9.000) ) {

                     st = NumberToString1000 (trace_ent.armorvalue);
                     if ( (trace_ent.undercover_skin != 0.000) ) {

                        centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nFriendly ",cls,"\n",st," armor\n");

                     } else {

                        centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nFriendly Spy\n",st," armor\n");

                     }
                     return ;

                  } else {

                     st = NumberToString1000 (trace_ent.armorvalue);
                     if ( (trace_ent.undercover_skin != 0.000) ) {

                        centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nFriendly ",cls);

                     } else {

                        centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nFriendly Spy\n");

                     }
                     return ;

                  }

               }

            }
            if ( (trace_ent.undercover_name != string_null) ) {

               if ( (trace_ent.undercover_skin != 0.000) ) {

                  centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nEnemy ",cls);

               } else {

                  centerprint (self,"\n\n\n\n",trace_ent.undercover_name,"\nEnemy Spy");

               }

            } else {

               if ( (trace_ent.undercover_skin != 0.000) ) {

                  centerprint (self,"\n\n\n\n",trace_ent.netname,"\nEnemy ",cls);

               } else {

                  centerprint (self,"\n\n\n\n",trace_ent.netname,"\nEnemy Spy");

               }

            }

         } else {

            cls = TeamFortress_GetClassName (trace_ent.playerclass);
            centerprint (self,"\n\n\n\n",trace_ent.netname,"\nEnemy ",cls);

         }

      } else {

         if ( (trace_ent.classname == "building_dispenser") ) {

            self.StatusRefreshTime = (time + 1.500);
            if ( (self == trace_ent.real_owner) ) {

               centerprint (self,"\n\n\n\nYour Dispenser");

            } else {

               centerprint (self,"\n\n\n\nDispenser made by ",trace_ent.real_owner.netname);

            }

         } else {

            if ( ((trace_ent.classname == "building_sentrygun") || (trace_ent.classname == "building_sentrygun_base")) ) {

               self.StatusRefreshTime = (time + 1.500);
               if ( (self == trace_ent.real_owner) ) {

                  centerprint (self,"\n\n\n\nYour SentryGun");

               } else {

                  if ( !teamplay ) {

                     centerprint (self,"\n\n\n\nSentrygun made by\n",trace_ent.real_owner.netname);

                  } else {

                     if ( ((self.team_no != 0.000) && (self.team_no == trace_ent.team_no)) ) {

                        centerprint (self,"\n\n\n\nFriendly Sentrygun made by\n",trace_ent.real_owner.netname);

                     } else {

                        centerprint (self,"\n\n\n\nEnemy Sentrygun made by\n",trace_ent.real_owner.netname);

                     }

                  }

               }

            }

         }

      }

   }

};

void () TeamFortress_ReloadCurrentWeapon = {

   local float rt;
   local entity tWeapon;

   if ( (self.tfstate & 2.000) ) {

      return ;

   }
   if ( (self.current_weapon == 128.000) ) {

      if ( (self.ammo_shells == 0.000) ) {

         sprint (self,2.000,"out of shells.\n");
         return ;

      }
      if ( (self.reload_shotgun == 0.000) ) {

         sprint (self,2.000,"clip full.\n");
         return ;

      }
      if ( ((8.000 - self.reload_shotgun) == self.ammo_shells) ) {

         sprint (self,2.000,"all shells are in the clip.\n");
         return ;

      }
      if ( (self.reload_shotgun < self.ammo_shells) ) {

         Attack_Finished (0.400);
         rt = ((8.000 - self.reload_shotgun) / 8.000);
         rt = (2.000 - (2.000 * rt));
         self.reload_shotgun = 0.000;
         if ( (self.ammo_shells < 8.000) ) {

            self.reload_shotgun = (8.000 - self.ammo_shells);

         }
         sprint (self,2.000,"reloading...\n");
         self.tfstate = (self.tfstate | 2.000);
         tWeapon = spawn ();
         tWeapon.owner = self;
         tWeapon.classname = "timer";
         tWeapon.nextthink = (time + rt);
         tWeapon.think = W_Reload_shotgun;
         self.weaponmodel = "";
         self.weaponframe = 0.000;

      } else {

         sprint (self,2.000,"not enough ammo to reload\n");

      }

   } else {

      if ( (self.current_weapon == 256.000) ) {

         if ( (self.ammo_shells == 0.000) ) {

            sprint (self,2.000,"out of shells.\n");
            return ;

         }
         if ( (self.reload_super_shotgun == 0.000) ) {

            sprint (self,2.000,"clip full.\n");
            return ;

         }
         if ( ((16.000 - self.reload_super_shotgun) == self.ammo_shells) ) {

            sprint (self,2.000,"all shells are in the clip.\n");
            return ;

         }
         if ( (self.reload_super_shotgun < self.ammo_shells) ) {

            Attack_Finished (0.700);
            rt = ((16.000 - self.reload_super_shotgun) / 16.000);
            rt = (3.000 - (3.000 * rt));
            self.reload_super_shotgun = 0.000;
            if ( (self.ammo_shells < 16.000) ) {

               self.reload_super_shotgun = (16.000 - self.ammo_shells);

            }
            sprint (self,2.000,"reloading...\n");
            self.tfstate = (self.tfstate | 2.000);
            tWeapon = spawn ();
            tWeapon.owner = self;
            tWeapon.classname = "timer";
            tWeapon.nextthink = (time + rt);
            tWeapon.think = W_Reload_super_shotgun;
            self.weaponmodel = "";
            self.weaponframe = 0.000;

         } else {

            sprint (self,2.000,"not enough ammo to reload\n");

         }

      } else {

         if ( (self.current_weapon == 2048.000) ) {

            if ( (self.ammo_rockets == 0.000) ) {

               sprint (self,2.000,"out of grenades.\n");
               return ;

            }
            if ( (self.reload_grenade_launcher == 0.000) ) {

               sprint (self,2.000,"clip full.\n");
               return ;

            }
            if ( ((6.000 - self.reload_grenade_launcher) == self.ammo_rockets) ) {

               sprint (self,2.000,"all grenades are in the clip.\n");
               return ;

            }
            if ( (self.reload_grenade_launcher < self.ammo_rockets) ) {

               Attack_Finished (0.600);
               rt = ((6.000 - self.reload_grenade_launcher) / 6.000);
               rt = (4.000 - (4.000 * rt));
               self.reload_grenade_launcher = 0.000;
               if ( (self.ammo_rockets < 6.000) ) {

                  self.reload_grenade_launcher = (6.000 - self.ammo_rockets);

               }
               sprint (self,2.000,"reloading...\n");
               self.tfstate = (self.tfstate | 2.000);
               tWeapon = spawn ();
               tWeapon.owner = self;
               tWeapon.classname = "timer";
               tWeapon.nextthink = (time + rt);
               tWeapon.think = W_Reload_grenade_launcher;
               self.weaponmodel = "";
               self.weaponframe = 0.000;

            } else {

               sprint (self,2.000,"not enough ammo to reload\n");

            }

         } else {

            if ( (self.current_weapon == 8192.000) ) {

               if ( (self.ammo_rockets == 0.000) ) {

                  sprint (self,2.000,"out of rockets.\n");
                  return ;

               }
               if ( (self.reload_rocket_launcher == 0.000) ) {

                  sprint (self,2.000,"clip full.\n");
                  return ;

               }
               if ( ((4.000 - self.reload_rocket_launcher) == self.ammo_rockets) ) {

                  sprint (self,2.000,"all rockets are in the clip.\n");
                  return ;

               }
               if ( (self.reload_rocket_launcher < self.ammo_rockets) ) {

                  Attack_Finished (0.800);
                  rt = ((4.000 - self.reload_rocket_launcher) / 4.000);
                  rt = (5.000 - (5.000 * rt));
                  self.reload_rocket_launcher = 0.000;
                  if ( (self.ammo_rockets < 4.000) ) {

                     self.reload_rocket_launcher = (4.000 - self.ammo_rockets);

                  }
                  sprint (self,2.000,"reloading...\n");
                  self.tfstate = (self.tfstate | 2.000);
                  tWeapon = spawn ();
                  tWeapon.owner = self;
                  tWeapon.classname = "timer";
                  tWeapon.nextthink = (time + rt);
                  tWeapon.think = W_Reload_rocket_launcher;
                  self.weaponmodel = "";
                  self.weaponframe = 0.000;

               }

            }

         }

      }

   }

};
