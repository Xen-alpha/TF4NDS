
void () knight_atk1;

void () knight_runatk1;

void () ogre_smash1;

void () ogre_swing1;

void () sham_smash1;

void () sham_swingr1;

void () sham_swingl1;

void (float side) Demon_Melee;

void () ai_face;

void () knight_attack = {

   local float len;

   len = vlen (((self.enemy.origin + self.enemy.view_ofs) - (self.origin + self.view_ofs)));
   if ( (len < 80.000) ) {

      knight_atk1 ();

   } else {

      knight_runatk1 ();

   }

};
float () CheckAttack = {

   local vector spot1;
   local vector spot2;
   local entity targ;
   local float chance;

   targ = self.enemy;
   spot1 = (self.origin + self.view_ofs);
   spot2 = (targ.origin + targ.view_ofs);
   traceline (spot1,spot2,0.000,self);
   if ( (trace_ent != targ) ) {

      return ( 0.000 );

   }
   if ( (trace_inopen && trace_inwater) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 0.000) ) {

      if ( self.th_melee ) {

         if ( (self.classname == "monster_knight") ) {

            knight_attack ();

         } else {

            self.th_melee ();

         }
         return ( 1.000 );

      }

   }
   if ( !self.th_missile ) {

      return ( 0.000 );

   }
   if ( (time < self.attack_finished) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 3.000) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 0.000) ) {

      chance = 0.900;
      self.attack_finished = 0.000;

   } else {

      if ( (enemy_range == 1.000) ) {

         if ( self.th_melee ) {

            chance = 0.200;

         } else {

            chance = 0.400;

         }

      } else {

         if ( (enemy_range == 2.000) ) {

            if ( self.th_melee ) {

               chance = 0.050;

            } else {

               chance = 0.100;

            }

         } else {

            chance = 0.000;

         }

      }

   }
   if ( (random () < chance) ) {

      self.th_missile ();
      SUB_AttackFinished ((2.000 * random ()));
      return ( 1.000 );

   }
   return ( 0.000 );

};

void () ai_face = {

   self.ideal_yaw = vectoyaw ((self.enemy.origin - self.origin));
   ChangeYaw ();

};

void (float d) ai_charge = {

   ai_face ();
   movetogoal (d);

};

void () ai_charge_side = {

   local vector dtemp;
   local float heading;

   self.ideal_yaw = vectoyaw ((self.enemy.origin - self.origin));
   ChangeYaw ();
   makevectors (self.angles);
   dtemp = (self.enemy.origin - (30.000 * v_right));
   heading = vectoyaw ((dtemp - self.origin));
   walkmove (heading,20.000);

};

void () ai_melee = {

   local vector delta;
   local float ldmg;

   if ( !self.enemy ) {

      return ;

   }
   delta = (self.enemy.origin - self.origin);
   if ( (vlen (delta) > 60.000) ) {

      return ;

   }
   ldmg = (((random () + random ()) + random ()) * 3.000);
   T_Damage (self.enemy,self,self,ldmg);

};

void () ai_melee_side = {

   local vector delta;
   local float ldmg;

   if ( !self.enemy ) {

      return ;

   }
   ai_charge_side ();
   delta = (self.enemy.origin - self.origin);
   if ( (vlen (delta) > 60.000) ) {

      return ;

   }
   if ( !CanDamage (self.enemy,self) ) {

      return ;

   }
   ldmg = (((random () + random ()) + random ()) * 3.000);
   T_Damage (self.enemy,self,self,ldmg);

};
float () SoldierCheckAttack = {

   local vector spot1;
   local vector spot2;
   local entity targ;
   local float chance;

   targ = self.enemy;
   spot1 = (self.origin + self.view_ofs);
   spot2 = (targ.origin + targ.view_ofs);
   traceline (spot1,spot2,0.000,self);
   if ( (trace_inopen && trace_inwater) ) {

      return ( 0.000 );

   }
   if ( (trace_ent != targ) ) {

      return ( 0.000 );

   }
   if ( (time < self.attack_finished) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 3.000) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 0.000) ) {

      chance = 0.900;

   } else {

      if ( (enemy_range == 1.000) ) {

         chance = 0.400;

      } else {

         if ( (enemy_range == 2.000) ) {

            chance = 0.050;

         } else {

            chance = 0.000;

         }

      }

   }
   if ( (random () < chance) ) {

      self.th_missile ();
      SUB_AttackFinished ((1.000 + random ()));
      if ( (random () < 0.300) ) {

         self.lefty = !self.lefty;

      }
      return ( 1.000 );

   }
   return ( 0.000 );

};
float () ShamCheckAttack = {

   local vector spot1;
   local vector spot2;
   local entity targ;
   local float chance;

   if ( (enemy_range == 0.000) ) {

      if ( CanDamage (self.enemy,self) ) {

         self.attack_state = 3.000;
         return ( 1.000 );

      }

   }
   if ( (time < self.attack_finished) ) {

      return ( 0.000 );

   }
   if ( !enemy_vis ) {

      return ( 0.000 );

   }
   targ = self.enemy;
   spot1 = (self.origin + self.view_ofs);
   spot2 = (targ.origin + targ.view_ofs);
   if ( (vlen ((spot1 - spot2)) > 600.000) ) {

      return ( 0.000 );

   }
   traceline (spot1,spot2,0.000,self);
   if ( (trace_inopen && trace_inwater) ) {

      return ( 0.000 );

   }
   if ( (trace_ent != targ) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 3.000) ) {

      return ( 0.000 );

   }
   self.attack_state = 4.000;
   SUB_AttackFinished ((2.000 + (2.000 * random ())));
   return ( 1.000 );

};
float () OgreCheckAttack = {

   local vector spot1;
   local vector spot2;
   local entity targ;
   local float chance;

   if ( (enemy_range == 0.000) ) {

      if ( CanDamage (self.enemy,self) ) {

         self.attack_state = 3.000;
         return ( 1.000 );

      }

   }
   if ( (time < self.attack_finished) ) {

      return ( 0.000 );

   }
   if ( !enemy_vis ) {

      return ( 0.000 );

   }
   targ = self.enemy;
   spot1 = (self.origin + self.view_ofs);
   spot2 = (targ.origin + targ.view_ofs);
   traceline (spot1,spot2,0.000,self);
   if ( (trace_inopen && trace_inwater) ) {

      return ( 0.000 );

   }
   if ( (trace_ent != targ) ) {

      return ( 0.000 );

   }
   if ( (time < self.attack_finished) ) {

      return ( 0.000 );

   }
   if ( (enemy_range == 3.000) ) {

      return ( 0.000 );

   } else {

      if ( (enemy_range == 1.000) ) {

         chance = 0.100;

      } else {

         if ( (enemy_range == 2.000) ) {

            chance = 0.050;

         } else {

            chance = 0.000;

         }

      }

   }
   self.attack_state = 4.000;
   SUB_AttackFinished ((1.000 + (2.000 * random ())));
   return ( 1.000 );

};
