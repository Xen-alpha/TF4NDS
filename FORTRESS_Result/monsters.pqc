float (entity targ) visible = {

   local vector spot1;
   local vector spot2;

   spot1 = (self.origin + self.view_ofs);
   spot2 = (targ.origin + targ.view_ofs);
   traceline (spot1,spot2,1.000,self);
   if ( (trace_inopen && trace_inwater) ) {

      return ( 0.000 );

   }
   if ( (trace_fraction == 1.000) ) {

      return ( 1.000 );

   }
   return ( 0.000 );

};

void () FoundTarget;

void () monster_use = {

   if ( self.enemy ) {

      return ;

   }
   if ( (self.health <= 0.000) ) {

      return ;

   }
   if ( (activator.items & 524288.000) ) {

      return ;

   }
   if ( (activator.flags & 128.000) ) {

      return ;

   }
   if ( (activator.classname != "player") ) {

      return ;

   }
   self.enemy = activator;
   self.nextthink = (time + 0.100);
   self.think = FoundTarget;

};

void () set_monster_health = {

   skill = cvar ("skill");
   if ( (skill > 2.000) ) {

      self.lives = (((skill - 2.000) * 10.000) - 1.000);
      skill = 3.000;

   }

};

void () monster_death_use = {

   local entity ent;

   if ( (self.flags & 1.000) ) {

      self.flags = (self.flags - 1.000);

   }
   if ( (self.flags & 2.000) ) {

      self.flags = (self.flags - 2.000);

   }
   if ( !self.target ) {

      return ;

   }
   activator = self.enemy;
   SUB_UseTargets ();

};

void () walkmonster_start_go = {

   local entity etemp;

   self.origin_z = (self.origin_z + 1.000);
   droptofloor ();
   if ( !walkmove (0.000,0.000) ) {

      dprint ("walkmonster in wall at: ");
      dprint (vtos (self.origin));
      dprint ("\n");

   }
   self.takedamage = 2.000;
   self.ideal_yaw = (self.angles * '0.000 1.000 0.000');
   if ( !self.yaw_speed ) {

      self.yaw_speed = 20.000;

   }
   self.view_ofs = '0.000 0.000 25.000';
   self.use = monster_use;
   self.flags = (self.flags | 32.000);
   if ( self.target ) {

      self.movetarget = find (world,targetname,self.target);
      self.goalentity = find (world,targetname,self.target);
      self.ideal_yaw = vectoyaw ((self.goalentity.origin - self.origin));
      if ( !self.movetarget ) {

         dprint ("Monster can't find target at ");
         dprint (vtos (self.origin));
         dprint ("\n");

      }
      if ( (self.movetarget.classname == "path_corner") ) {

         self.th_walk ();

      } else {

         self.pausetime = 100000000.000;

      }
      self.th_stand ();

   } else {

      self.pausetime = 100000000.000;
      self.th_stand ();

   }
   self.nextthink = (self.nextthink + (random () * 0.500));

};

void () walkmonster_start = {

   self.nextthink = (self.nextthink + (random () * 0.500));
   self.think = walkmonster_start_go;
   total_monsters = (total_monsters + 1.000);
   set_monster_health ();

};

void () flymonster_start_go = {

   self.takedamage = 2.000;
   self.ideal_yaw = (self.angles * '0.000 1.000 0.000');
   if ( !self.yaw_speed ) {

      self.yaw_speed = 10.000;

   }
   self.view_ofs = '0.000 0.000 25.000';
   self.use = monster_use;
   self.flags = (self.flags | 1.000);
   self.flags = (self.flags | 32.000);
   if ( !walkmove (0.000,0.000) ) {

      dprint ("flymonster in wall at: ");
      dprint (vtos (self.origin));
      dprint ("\n");

   }
   if ( self.target ) {

      self.movetarget = find (world,targetname,self.target);
      self.goalentity = find (world,targetname,self.target);
      if ( !self.movetarget ) {

         dprint ("Monster can't find target at ");
         dprint (vtos (self.origin));
         dprint ("\n");

      }
      if ( (self.movetarget.classname == "path_corner") ) {

         self.th_walk ();

      } else {

         self.pausetime = 100000000.000;

      }
      self.th_stand ();

   } else {

      self.pausetime = 100000000.000;
      self.th_stand ();

   }

};

void () flymonster_start = {

   self.nextthink = (self.nextthink + (random () * 0.500));
   self.think = flymonster_start_go;
   total_monsters = (total_monsters + 1.000);
   set_monster_health ();

};

void () swimmonster_start_go = {

   if ( deathmatch ) {

      dremove (self);
      return ;

   }
   self.takedamage = 2.000;
   total_monsters = (total_monsters + 1.000);
   self.ideal_yaw = (self.angles * '0.000 1.000 0.000');
   if ( !self.yaw_speed ) {

      self.yaw_speed = 10.000;

   }
   self.view_ofs = '0.000 0.000 10.000';
   self.use = monster_use;
   self.flags = (self.flags | 2.000);
   self.flags = (self.flags | 32.000);
   if ( self.target ) {

      self.movetarget = find (world,targetname,self.target);
      self.goalentity = find (world,targetname,self.target);
      if ( !self.movetarget ) {

         dprint ("Monster can't find target at ");
         dprint (vtos (self.origin));
         dprint ("\n");

      }
      self.ideal_yaw = vectoyaw ((self.goalentity.origin - self.origin));
      self.th_walk ();

   } else {

      self.pausetime = 100000000.000;
      self.th_stand ();

   }
   self.nextthink = (self.nextthink + (random () * 0.500));

};

void () swimmonster_start = {

   self.nextthink = (self.nextthink + (random () * 0.500));
   self.think = swimmonster_start_go;
   total_monsters = (total_monsters + 1.000);
   set_monster_health ();

};
