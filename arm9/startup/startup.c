/*---------------------------------------------------------------------------------

	QWTF Lite Port Startup code
	-- generated by Maniac Xena
	-- QWTF is Team Fortress Software's property
	-- based on cquake project source code

---------------------------------------------------------------------------------*/
// local modules
#include <host.h>
#include <input.h>
#include <video.h>

// system modules
#include <stdio.h>
#include <unistd.h> // iprintf, only available in unix

u16 *ds_display_top;
u16 *ds_display_bottom;
int		ds_display_bottom_height;
u16 *ds_display_menu;

int ds_bg_sub = 0;
int ds_bg_main = 0;
int ds_bg_text = 0;

void Sys_Init()
{
	// TODO: Check if the code turn on everything?
	// powerOn(POWER_ALL);

	//put 3D on top
	lcdMainOnTop();

	vramSetPrimaryBanks(VRAM_A_TEXTURE, VRAM_B_TEXTURE, VRAM_C_TEXTURE, VRAM_D_TEXTURE);
	vramSetBankE(VRAM_E_MAIN_BG);
	vramSetBankF(VRAM_F_TEX_PALETTE);
	vramSetBankG((VRAM_G_TYPE)(1 | VRAM_OFFSET(2)));
	vramSetBankH(VRAM_H_SUB_BG);
	vramSetBankI(VRAM_I_SUB_BG_0x06208000);

	// Subscreen as a console
	videoSetModeSub(MODE_5_2D | DISPLAY_BG0_ACTIVE | DISPLAY_BG2_ACTIVE/* | DISPLAY_BG3_ACTIVE*/);

	ds_bg_sub = bgInitSub(2, BgType_Bmp8, BgSize_B8_256x256, 0, 0);


	videoSetMode(MODE_3_3D | DISPLAY_BG1_ACTIVE | DISPLAY_BG2_ACTIVE | DISPLAY_BG3_ACTIVE);
	bgSetPriority(0, 3);


	//setup stdout
	consoleInit(0, 1, BgType_Text4bpp, BgSize_T_256x256, 14, 0, true, true);
	BG_PALETTE[0] = 0;
	BG_PALETTE[255] = 0xffff;

	//setup text layer for fps, center print, and Con_Printf temp overlay
	ds_bg_text = bgInit(2, BgType_Text4bpp, BgSize_T_256x256, 15, 0);
	bgSetPriority(ds_bg_text, 0);

	//setup top bitmap for console
	ds_bg_main = bgInit(3, BgType_Bmp8, BgSize_B8_256x256, 2, 0);
	bgSetPriority(ds_bg_main, 1);

	ds_display_bottom_height = 192;
	ds_display_menu = ds_display_bottom = (u16*)bgGetGfxPtr(ds_bg_main);
	ds_display_top = (u16*)bgGetGfxPtr(ds_bg_sub);

	irqSet(IRQ_VBLANK, VID_loadPal);

	lcdMainOnBottom();

	glInit();
	glEnable(GL_TEXTURE_2D);

	glClearColor(0, 0, 0, 31); // BG must be opaque for AA to work
	glClearPolyID(63); // BG must have a unique polygon ID for AA to work

	glPolyFmt(POLY_ALPHA(31) | POLY_CULL_FRONT | POLY_ID(0) | (1 << 13));
	glCutoffDepth(0x7FFF);

	glColor3f(1, 1, 1);

	glViewport(0, 0, 255, 191);


	glMatrixMode(GL_TEXTURE);
	glLoadIdentity();

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(73.74, 256.0 / 192.0, 0.005, 40.0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// TODO: we must Initialize libfat system
	// DISK INIT START

	// DISK INIT END

	// frame timer initialization
	TIMER_DATA(0) = 0x10000 - (0x1000000 / 11025) * 2;
	TIMER_CR(0) = TIMER_ENABLE | TIMER_DIV_1;
	TIMER_DATA(1) = 0;
	TIMER_CR(1) = TIMER_ENABLE | TIMER_CASCADE | TIMER_DIV_1;
	TIMER_DATA(2) = 0;
	TIMER_CR(2) = TIMER_ENABLE | TIMER_CASCADE | TIMER_DIV_1;

	soundEnable();

	defaultExceptionHandler();

	return;
}
//---------------------------------------------------------------------------------
#include <quakedef.h>

#define MAX_CMD_LINE (512)
char* argv[MAX_NUM_ARGVS];
char		cmdLine[MAX_CMD_LINE + 1];
static char* empty_string = "";

void read_cquake_ini(quakeparms_t* parms)
{
	// TODO: Fill the rest of the process
	int cb;
	char* lpCmdLine;

	lpCmdLine = &cmdLine[0]; // lpCmdLine points cmdLine
	memset(lpCmdLine, 0, sizeof(cmdLine));
	// 1. open and read "tf.ini", copy the content to cmdLine and and close the file
	// FILE *f;
	// 2. parse lpCmdLine 
	parms->argc = 1;
	argv[0] = empty_string;
	while (*lpCmdLine && (parms->argc < MAX_NUM_ARGVS))
	{
		while (*lpCmdLine && ((*lpCmdLine <= 32) || (*lpCmdLine > 126)))
			lpCmdLine++;

		if (*lpCmdLine)
		{
			argv[parms->argc] = lpCmdLine;
			parms->argc++;

			while (*lpCmdLine && ((*lpCmdLine > 32) && (*lpCmdLine <= 126)))
				lpCmdLine++;

			if (*lpCmdLine)
			{
				*lpCmdLine = 0;
				lpCmdLine++;
			}

		}
	}
	parms->argv = argv;
	// 3. call COM_InitArgv
	
	return;
}
//---------------------------------------------------------------------------------

long long ds_time()
{
	static u16 last;
	static long long t;
	u16 time1 = TIMER1_DATA;
	u16 time = TIMER2_DATA;
	if (time < last) {
		t += (1 << 32);
	}
	last = time;
	return (t + (time << 16) + time1);
}
int Sys_IntTime(void)
{
	return ds_time();
}
double Sys_FloatTime(void)
{
	return ds_time() / 11025.0;
}

int enable_texture_cache = 1;

#include <host.h>

int main(void) {
	Sys_Init();

	//---------------------------------------------------------------------------------
	// now extracting quake_main(argc,argv) process
	float rotateX = 0.0;
	float rotateY = 0.0;
	double newtime, oldtime, time;

	static quakeparms_t    parms;
	static int i = 0;

	unsigned amt = MINIMUM_MEMORY; // 2900*1024

	int frame = 0;
	parms.basedir = "";
	read_cquake_ini(&parms); // TODO: read cquake.ini

	parms.memsize = MINIMUM_MEMORY;
	enable_texture_cache = 0;

	parms.membase = malloc(parms.memsize);

	Host_Init(&parms);
	oldtime = Sys_FloatTime();

	while (1) {
		processInput(); // Note: This must be the first code inside this infinite loop
		
		newtime = Sys_FloatTime();
		time = newtime - oldtime;

		Host_Frame(time);
		oldtime = newtime;

		swiWaitForVBlank(); // blit screen

		if (keysDown() & KEY_START) Host_Exit();
		frame++;
	}

	return 0;
}
